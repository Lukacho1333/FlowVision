#!/usr/bin/env node

/**
 * GitHub Issue Creator from AI Conversation Context
 * Automatically creates GitHub issues from conversation requirements
 */

const fs = require('fs');
const path = require('path');

class GitHubIssueCreator {
  constructor() {
    this.issueTemplate = this.loadIssueTemplate();
    this.sprintConfig = this.loadSprintConfig();
  }

  /**
   * Parse conversation requirements into GitHub issues
   */
  async parseRequirementsToIssues(requirements) {
    console.log('📋 Parsing requirements into GitHub issues...');
    
    const issues = [];
    
    for (const requirement of requirements) {
      const issue = await this.createIssueFromRequirement(requirement);
      issues.push(issue);
    }
    
    return issues;
  }

  /**
   * Create GitHub issue from a single requirement
   */
  async createIssueFromRequirement(requirement) {
    console.log(`📝 Creating issue for: ${requirement.title || requirement.slice(0, 50)}...`);
    
    const issue = {
      title: this.extractTitle(requirement),
      body: this.generateIssueBody(requirement),
      labels: this.assignLabels(requirement),
      milestone: this.getCurrentMilestone(),
      assignees: this.suggestAssignees(requirement),
      storyPoints: this.estimateStoryPoints(requirement),
      acceptanceCriteria: this.extractAcceptanceCriteria(requirement),
    };
    
    // In real implementation, this would call GitHub API
    console.log(`✅ Issue created: ${issue.title}`);
    
    return issue;
  }

  /**
   * Extract title from requirement text
   */
  extractTitle(requirement) {
    if (typeof requirement === 'object' && requirement.title) {
      return requirement.title;
    }
    
    // Extract first sentence or up to 50 characters
    const text = typeof requirement === 'string' ? requirement : requirement.description;
    const firstSentence = text.split('.')[0];
    return firstSentence.length > 50 ? firstSentence.slice(0, 50) + '...' : firstSentence;
  }

  /**
   * Generate GitHub issue body with template
   */
  generateIssueBody(requirement) {
    const description = typeof requirement === 'string' ? requirement : requirement.description;
    const storyPoints = this.estimateStoryPoints(requirement);
    const acceptanceCriteria = this.extractAcceptanceCriteria(requirement);
    
    return `## 📋 User Story

${description}

## 🎯 Acceptance Criteria

${acceptanceCriteria.map(criteria => `- [ ] ${criteria}`).join('\n')}

## 📊 Story Points

**Estimated**: ${storyPoints} points

## 🏷️ Labels

- \`sprint-18\`
- \`ai-driven-development\`
- \`${this.categorizeRequirement(requirement)}\`

## 👨‍💻 Expert Consultation Required

- [ ] Technical Architect review
- [ ] Expert profile validation
- [ ] Quality gates definition

## 🔗 Related Issues

- Relates to Sprint 18: AI-Driven Development Foundation
- Part of structured development optimization

---

*Generated by AI Project Orchestrator*
*Sprint: ${this.getCurrentMilestone()}*
*Created: ${new Date().toISOString()}*
`;
  }

  /**
   * Assign appropriate labels based on requirement content
   */
  assignLabels(requirement) {
    const text = (typeof requirement === 'string' ? requirement : requirement.description).toLowerCase();
    const labels = ['sprint-18', 'ai-driven-development'];
    
    // Category-based labels
    if (text.includes('agent') || text.includes('automation')) {
      labels.push('automation');
    }
    if (text.includes('structure') || text.includes('folder') || text.includes('organization')) {
      labels.push('structure');
    }
    if (text.includes('monitor') || text.includes('chat') || text.includes('context')) {
      labels.push('monitoring');
    }
    if (text.includes('sprint') || text.includes('tracking') || text.includes('github')) {
      labels.push('project-management');
    }
    
    // Priority labels
    if (text.includes('critical') || text.includes('blocker')) {
      labels.push('priority:high');
    } else if (text.includes('important') || text.includes('should')) {
      labels.push('priority:medium');
    } else {
      labels.push('priority:low');
    }
    
    return labels;
  }

  /**
   * Suggest assignees based on requirement type
   */
  suggestAssignees(requirement) {
    const text = (typeof requirement === 'string' ? requirement : requirement.description).toLowerCase();
    
    // Map requirement types to team members
    if (text.includes('architecture') || text.includes('technical')) {
      return ['technical-architect'];
    }
    if (text.includes('ai') || text.includes('agent')) {
      return ['ai-architect'];
    }
    if (text.includes('security')) {
      return ['security-architect'];
    }
    if (text.includes('ux') || text.includes('design')) {
      return ['ux-strategist'];
    }
    
    return ['project-orchestrator'];
  }

  /**
   * Estimate story points based on requirement complexity
   */
  estimateStoryPoints(requirement) {
    const text = (typeof requirement === 'string' ? requirement : requirement.description).toLowerCase();
    const complexity = this.assessComplexity(text);
    
    // Story point mapping based on complexity
    const pointMap = {
      'low': 3,
      'medium': 5,
      'high': 8,
      'very-high': 13
    };
    
    return pointMap[complexity] || 5;
  }

  /**
   * Assess requirement complexity
   */
  assessComplexity(text) {
    let complexityScore = 0;
    
    // Complexity indicators
    const indicators = {
      'setup': 1,
      'implement': 2,
      'integrate': 3,
      'optimize': 2,
      'monitor': 2,
      'automation': 3,
      'framework': 4,
      'architecture': 4,
      'system': 3,
      'background': 3,
      'ai': 3,
      'agent': 3
    };
    
    Object.entries(indicators).forEach(([keyword, score]) => {
      if (text.includes(keyword)) {
        complexityScore += score;
      }
    });
    
    // Map score to complexity level
    if (complexityScore <= 3) return 'low';
    if (complexityScore <= 6) return 'medium';
    if (complexityScore <= 10) return 'high';
    return 'very-high';
  }

  /**
   * Extract acceptance criteria from requirement
   */
  extractAcceptanceCriteria(requirement) {
    const defaultCriteria = [
      'Implementation follows .cursorrules standards',
      'Expert profile consultation completed',
      'Quality gates passed',
      'Documentation updated',
      'Tests written and passing'
    ];
    
    if (typeof requirement === 'object' && requirement.acceptanceCriteria) {
      return requirement.acceptanceCriteria;
    }
    
    return defaultCriteria;
  }

  /**
   * Categorize requirement for labeling
   */
  categorizeRequirement(requirement) {
    const text = (typeof requirement === 'string' ? requirement : requirement.description).toLowerCase();
    
    if (text.includes('automation') || text.includes('agent')) return 'automation';
    if (text.includes('structure') || text.includes('organization')) return 'structure';
    if (text.includes('monitor') || text.includes('tracking')) return 'monitoring';
    if (text.includes('sprint') || text.includes('github')) return 'project-management';
    if (text.includes('quality') || text.includes('testing')) return 'quality';
    
    return 'feature';
  }

  /**
   * Get current milestone/sprint
   */
  getCurrentMilestone() {
    return 'Sprint 18.1 - AI-Driven Development Foundation';
  }

  /**
   * Load issue template
   */
  loadIssueTemplate() {
    // In real implementation, load from .github/ISSUE_TEMPLATE/
    return {
      userStory: true,
      acceptanceCriteria: true,
      storyPoints: true,
      expertConsultation: true
    };
  }

  /**
   * Load sprint configuration
   */
  loadSprintConfig() {
    return {
      currentSprint: 'Sprint 18.1',
      sprintGoal: 'AI-Driven Development Foundation',
      capacity: 45,
      used: 18
    };
  }

  /**
   * Generate GitHub CLI commands for issue creation
   */
  generateGitHubCLICommands(issues) {
    console.log('🔧 Generating GitHub CLI commands...');
    
    const commands = issues.map(issue => {
      const labels = issue.labels.join(',');
      const assignees = issue.assignees.join(',');
      
      return `gh issue create \\
  --title "${issue.title}" \\
  --body "${issue.body.replace(/"/g, '\\"')}" \\
  --label "${labels}" \\
  --assignee "${assignees}" \\
  --milestone "${issue.milestone}"`;
    });
    
    return commands;
  }

  /**
   * Save issues to file for review
   */
  async saveIssuesToFile(issues) {
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `generated-issues-${timestamp}.json`;
    const filepath = path.join('.cursor', 'context', filename);
    
    const issueData = {
      timestamp: new Date().toISOString(),
      sprint: this.getCurrentMilestone(),
      totalIssues: issues.length,
      estimatedPoints: issues.reduce((sum, issue) => sum + issue.storyPoints, 0),
      issues
    };
    
    fs.writeFileSync(filepath, JSON.stringify(issueData, null, 2));
    console.log(`💾 Issues saved to: ${filepath}`);
    
    return filepath;
  }
}

// CLI interface
if (require.main === module) {
  const creator = new GitHubIssueCreator();
  
  // Example requirements from current conversation
  const requirements = [
    {
      title: 'Complete Cursor background agent setup',
      description: 'Implement background agents for code quality, testing, security, documentation, and performance monitoring with real-time triggers and automated execution.',
      priority: 'high'
    },
    {
      title: 'Implement AI-driven sprint tracking system',
      description: 'Create automated system for tracking sprint progress, updating GitHub issues, calculating velocity, and identifying blockers through AI Project Orchestrator.',
      priority: 'high'
    },
    {
      title: 'Setup GitHub issue automation from conversation context',
      description: 'Enable automatic creation of GitHub issues from conversation requirements with proper labels, story points, and acceptance criteria.',
      priority: 'medium'
    },
    {
      title: 'Configure expert profile integration in AI agents',
      description: 'Integrate expert profiles system with AI agents for automated consultation, validation, and decision-making following expert frameworks.',
      priority: 'medium'
    }
  ];
  
  creator.parseRequirementsToIssues(requirements)
    .then(issues => {
      console.log(`\n✅ Generated ${issues.length} GitHub issues`);
      
      const commands = creator.generateGitHubCLICommands(issues);
      console.log('\n🔧 GitHub CLI Commands:');
      commands.forEach((cmd, i) => {
        console.log(`\n# Issue ${i + 1}: ${issues[i].title}`);
        console.log(cmd);
      });
      
      return creator.saveIssuesToFile(issues);
    })
    .then(filepath => {
      console.log(`\n💾 Issues saved to: ${filepath}`);
      console.log('\n🚀 Ready to create GitHub issues!');
    })
    .catch(console.error);
}

module.exports = GitHubIssueCreator;
